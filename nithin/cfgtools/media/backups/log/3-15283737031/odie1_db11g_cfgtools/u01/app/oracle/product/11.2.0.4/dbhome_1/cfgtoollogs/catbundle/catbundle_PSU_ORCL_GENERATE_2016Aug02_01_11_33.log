Generating apply and rollback scripts...
Check the following file for errors:
/u01/app/oracle/product/11.2.0.4/dbhome_1/cfgtoollogs/catbundle/catbundle_PSU_ORCL_GENERATE_2016Aug02_01_11_33.log
SQL> 
SQL> REM Add new column to registry$history and dba_registry_history if needed
SQL> BEGIN
  2    EXECUTE IMMEDIATE
  3      'ALTER TABLE registry$history ADD (bundle_series VARCHAR2(30))';
  4    -- 7391049: Recompile dbms_registry_sys so there are no more invalid objects
  5    EXECUTE IMMEDIATE
  6      'ALTER PACKAGE sys.dbms_registry_sys COMPILE BODY';
  7  EXCEPTION
  8    WHEN OTHERS THEN
  9      IF SQLCODE = -1430 THEN
 10        -- Column already exists in table, just ignore the error
 11        NULL;
 12      ELSE
 13        RAISE;
 14      END IF;
 15  END;
 16  /

PL/SQL procedure successfully completed.

SQL> 
SQL> CREATE OR REPLACE VIEW dba_registry_history (
  2    action_time, action, namespace, version, id, bundle_series, comments)
  3  AS
  4    SELECT action_time, action, namespace, version, id, bundle_series, comments
  5      FROM registry$history;

View created.

SQL> 
SQL> REM 7391049: Recreate synonym so there are no more invalid objects
SQL> CREATE OR REPLACE PUBLIC SYNONYM
  2    dba_registry_history FOR dba_registry_history;

Synonym created.

SQL> 
SQL> REM Create temporary table
SQL> CREATE GLOBAL TEMPORARY TABLE bundle_component_files
  2    (cid           VARCHAR2(25),
  3     fname         VARCHAR2(100),
  4     seq           NUMBER,
  5     priority      NUMBER,
  6     rollback_only CHAR(1),
  7     UNIQUE(cid, fname))
  8    ON COMMIT PRESERVE ROWS;

Table created.

SQL> 
SQL> REM Disable Symlink/Mountpoint checks (required for windows platform)
SQL> DECLARE
  2    kolfuseslf_cnt      NUMBER := 0;
  3    stmt                VARCHAR2(1000);
  4  BEGIN
  5    -- alter session: enable use of symbolic links
  6    -- first get the current value of _kolfuseslf (default FALSE)
  7    stmt := 'SELECT COUNT(*) FROM V$PARAMETER WHERE NAME=''_kolfuseslf''';
  8    EXECUTE IMMEDIATE stmt INTO kolfuseslf_cnt;
  9    IF kolfuseslf_cnt != 0 THEN
 10      stmt := 'SELECT VALUE INTO :kolfuseslf FROM V$PARAMETER WHERE NAME=''_kolfuseslf''';
 11      EXECUTE IMMEDIATE stmt;
 12    END IF;
 13    stmt := 'ALTER SESSION SET "_kolfuseslf" = TRUE';
 14    EXECUTE IMMEDIATE stmt;
 15  END;
 16  /

PL/SQL procedure successfully completed.

SQL> 
SQL> REM And go for it
SQL> DECLARE
  2    bundledata XMLType;
  3    bundle     XMLType;
  4    component  XMLType;
  5  
  6    bundledataVersion          VARCHAR2(50);
  7    xmlFilename                VARCHAR2(50);
  8    bundleID                   NUMBER;
  9    bundleDescription          VARCHAR2(100);
 10    installedBundle            NUMBER;
 11    installedBundleDescription VARCHAR2(100);
 12    patchMode                  VARCHAR2(50) := NLS_UPPER('&patch_mode');
 13    bundleSeries               VARCHAR2(50) := NLS_UPPER('&bundle_series');
 14    startingBundle             NUMBER;
 15    currentDBVersion           VARCHAR2(20);
 16    rollbackOnly               CHAR(1);
 17    spoolCommand               VARCHAR2(500);
 18  
 19    filename    VARCHAR2(100);
 20    priority    NUMBER;
 21    componentID VARCHAR2(30);
 22  
 23    filenameSeq BINARY_INTEGER := 1;
 24  
 25    compHeaderWritten BOOLEAN := TRUE;
 26  
 27    fileopenFailed EXCEPTION;
 28    PRAGMA EXCEPTION_INIT(fileopenFailed, -22288);
 29    invalidMode    EXCEPTION;
 30  
 31    applyScriptFilePtr    UTL_FILE.FILE_TYPE;
 32    rollbackScriptFilePtr UTL_FILE.FILE_TYPE;
 33  
 34    platform v$database.platform_name%TYPE;
 35  
 36    CURSOR reverseBundleIDsCur(x XMLType) IS
 37      SELECT extract(column_value, '/bundle/@id').getNumberVal() bundleID
 38        FROM XMLTable('/bundledata/bundle' PASSING x)
 39        ORDER BY bundleID DESC;
 40  
 41    CURSOR bundleCur(x XMLType) IS
 42      SELECT column_value,
 43             extract(column_value, '/bundle/@id').getNumberVal() bundleID,
 44             extract(column_value, '/bundle/@description').getStringVal() bundleDesc
 45        FROM XMLTable('/bundledata/bundle' PASSING x)
 46        ORDER BY bundleID;
 47  
 48    CURSOR componentCur(x XMLType) IS
 49      SELECT column_value,
 50             extract(column_value, '/component/@id').getStringVal()
 51        FROM XMLTable('/bundle/component' PASSING x);
 52  
 53    -- 10413872: Add priority
 54    CURSOR fileCur(x XMLType) IS
 55      SELECT c."Filename", extract(column_value, '/file/@priority').getNumberVal() priority
 56         FROM XMLTable('/component/file'
 57                       PASSING x
 58                       COLUMNS "Filename" VARCHAR2(100) PATH '/file') c;
 59  
 60    CURSOR componentInfoCur (x XMLType) IS
 61      SELECT DISTINCT
 62             extract(column_value, '/component/@id').getStringVal() compID,
 63             extract(column_value, '/component/@name').getStringVal() compName,
 64             extract(column_value, '/component/@schema').getStringVal() compSchema
 65        FROM XMLTable('/bundledata/bundle/component' PASSING x)
 66        ORDER BY compSchema;
 67  
 68    CURSOR bundleComponentFilesCur (compID VARCHAR2) IS
 69      SELECT fname, rollback_only
 70        FROM bundle_component_files
 71        WHERE cid = compID
 72        ORDER BY priority, seq;
 73  
 74    PROCEDURE openScriptFiles(apply_file_name IN VARCHAR2,
 75                              rollback_file_name IN VARCHAR2) IS
 76    BEGIN
 77      applyScriptFilePtr := UTL_FILE.FOPEN('ADMIN_DIR', apply_file_name, 'w');
 78      rollbackScriptFilePtr :=
 79        UTL_FILE.FOPEN('ADMIN_DIR', rollback_file_name, 'w');
 80    EXCEPTION
 81      WHEN UTL_FILE.INVALID_PATH THEN
 82        RAISE_APPLICATION_ERROR(-20000, 'INVALID_PATH during openScriptFile');
 83      WHEN UTL_FILE.INVALID_MODE THEN
 84        RAISE_APPLICATION_ERROR(-20000, 'INVALID_MODE during openScriptFile');
 85      WHEN UTL_FILE.INVALID_OPERATION THEN
 86        RAISE_APPLICATION_ERROR(-20000,
 87                                'INVALID_OPERATION during openScriptFile');
 88      WHEN UTL_FILE.INVALID_MAXLINESIZE THEN
 89        RAISE_APPLICATION_ERROR(-20000,
 90                                'INVALID_MAXLINESIZE during openScriptFile');
 91    END openScriptFiles;
 92  
 93    -- If script is 'A', then input_line will be written to the apply script.
 94    -- If script is 'R', then input_line will be written to the rollback script.
 95    -- If script is 'B', then input_line will be written to both scripts.
 96    PROCEDURE insertScriptFile(script IN CHAR,
 97                               input_line IN VARCHAR2) IS
 98    BEGIN
 99      IF script = 'A' OR script = 'B' THEN
100        UTL_FILE.PUT_LINE(applyScriptFilePtr, input_line);
101      END IF;
102      IF script = 'R' OR script = 'B' THEN
103        UTL_FILE.PUT_LINE(rollbackScriptFilePtr, input_line);
104      END IF;
105    EXCEPTION
106      WHEN UTL_FILE.INVALID_FILEHANDLE THEN
107        RAISE_APPLICATION_ERROR(-20000,
108                                'INVALID_FILEHANDLE during insertScriptFile');
109      WHEN UTL_FILE.INVALID_OPERATION THEN
110        RAISE_APPLICATION_ERROR(-20000,
111                                'INVALID_OPERATION during insertScriptFile');
112      WHEN UTL_FILE.WRITE_ERROR THEN
113        RAISE_APPLICATION_ERROR(-20000,
114                                'WRITE_ERROR during insertScriptFile');
115    END insertScriptFile;
116  
117    PROCEDURE closeScriptFiles IS
118    BEGIN
119      UTL_FILE.FCLOSE(applyScriptFilePtr);
120      UTL_FILE.FCLOSE(rollbackScriptFilePtr);
121    EXCEPTION
122      WHEN UTL_FILE.INVALID_FILEHANDLE THEN
123        RAISE_APPLICATION_ERROR(-20000,
124                                'INVALID_FILEHANDLE during closeScriptFile');
125      WHEN UTL_FILE.WRITE_ERROR THEN
126        RAISE_APPLICATION_ERROR(-20000,
127                                'WRITE_ERROR during closeScriptFile');
128    END closeScriptFiles;
129  
130    -- Returns the first 4 digits of a version (i.e. '10.2.0.4' is returned
131    -- from the input string '10.2.0.4.3')
132    FUNCTION versionTrim(version IN VARCHAR2) RETURN VARCHAR2 IS
133    BEGIN
134      RETURN SUBSTR(version, 1, INSTR(version, '.', 1, 4) - 1);
135    END versionTrim;
136  
137    FUNCTION componentOK(component IN VARCHAR2)
138      RETURN BOOLEAN IS
139  
140    BEGIN
141      -- This is modeled off of dbms_registry_sys.cpu_script().
142      IF sys.dbms_registry.is_in_registry(component) AND
143         sys.dbms_registry.status(component) NOT IN ('REMOVING', 'REMOVED') AND
144         versionTrim(sys.dbms_registry.version(component)) = currentDBVersion THEN
145        RETURN TRUE;
146      ELSE
147        RETURN FALSE;
148      END IF;
149    END componentOK;
150  
151  BEGIN
152    EXECUTE IMMEDIATE
153      'CREATE OR REPLACE DIRECTORY admin_dir AS ''' || :rdbmsAdminDir || '''';
154  
155    xmlFilename := 'bundledata_' || bundleSeries || '.xml';
156  
157    -- 8498426: Set namespace
158    sys.dbms_registry.set_session_namespace('SERVER');
159  
160    -- Load XML data file
161    bundledata :=
162      XMLType(bfilename('ADMIN_DIR', xmlFilename), nls_charset_id('US7ASCII'));
163  
164    -- 10413872: Get version of bundledata.xml so we know what fields to
165    -- look for
166    BEGIN
167      SELECT extract(column_value, '/bundledata/@version').getNumberVal()
168        INTO bundledataVersion
169        FROM XMLTable('/bundledata' PASSING bundledata);
170    EXCEPTION
171      WHEN OTHERS THEN
172        IF sqlcode = -1722 THEN
173          -- Invalid number, version is not valid so assume 0
174          bundledataVersion := 0;
175        ELSE
176          RAISE;
177        END IF;
178    END;
179  
180    -- Set :scriptFile to the right value.  When this block completes, we will
181    -- run :scriptFile after cleaning up the temporary objects
182    IF patchMode = 'ROLLBACK' THEN
183      :scriptFile := :rollbackScriptFile;
184      RETURN;  -- No need to actually generate anything
185    ELSIF patchMode = 'APPLY' THEN
186      :scriptFile := :applyScriptFile;
187    ELSIF patchMode != 'APPLY' THEN
188      RAISE invalidMode;
189    END IF;
190  
191    -- Get database version.  We only want the first 4 digits (i.e. 10.2.0.4).
192    SELECT version
193      INTO currentDBVersion
194      FROM v$instance;
195    currentDBVersion := versionTrim(currentDBVersion);
196  
197    -- Determine current bundle installed.
198    DECLARE
199      historyRec registry$history%ROWTYPE;
200    BEGIN
201      SELECT *
202        INTO historyRec
203        FROM registry$history
204        WHERE action_time =
205          (SELECT MAX(action_time)
206             FROM registry$history
207             WHERE namespace = 'SERVER'
208             AND bundle_series = bundleSeries
209             AND version = currentDBVersion);
210  
211      IF historyRec.action = 'ROLLBACK' THEN
212        -- Latest entry is bundle rollback, therefore no bundle applied
213        installedBundle := 0;
214        installedBundleDescription := 'None';
215      ELSIF historyRec.action  = 'APPLY' THEN
216        -- Latest entry is a bundle apply, return it
217        installedBundle := historyRec.id;
218        installedBundleDescription := historyRec.comments;
219      ELSE
220        -- Latest entry is something else, therefore assume no bundle applied
221        installedBundle := 0;
222        installedBundleDescription := 'None';
223      END IF;
224    EXCEPTION
225      WHEN NO_DATA_FOUND THEN
226        -- No entries, therefore no bundle applied
227        installedBundle := 0;
228        installedBundleDescription := 'None';
229    END;
230  
231    DBMS_OUTPUT.PUT_LINE('Current bundle installed: (' || installedBundle ||
232                         ') - ' || installedBundleDescription);
233  
234    -- Determine which bundle to start with in the current install.
235    FOR bundleRec IN reverseBundleIDsCur(bundledata) LOOP
236      -- If there is no bundle installed, assign to starting_bundle.  Since this
237      -- loop is in descending order, we will end up with starting_bundle =
238      -- the earliest bundle ID in the data file.
239      IF installedBundle IS NULL THEN
240        startingBundle := bundleRec.bundleID;
241      ELSE
242        -- Ensure that the latest bundle will at least be installed.  This covers
243        -- the case where we are re-installing the latest bundle again.
244        IF startingBundle IS NULL THEN
245           startingBundle := bundleRec.bundleID;
246        END IF;
247  
248        -- If the fetched bundle ID > installed bundle ID, we need to install
249        -- the fetched bundle ID.
250        IF bundleRec.bundleID > installedBundle THEN
251          startingBundle := bundleRec.bundleID;
252        END IF;
253      END IF;
254    END LOOP;
255  
256    DBMS_OUTPUT.PUT_LINE('Starting bundle ID: ' || startingBundle);
257  
258    -- For each bundle:
259    OPEN bundleCur(bundledata);
260    LOOP
261      FETCH bundleCur INTO bundle, bundleID, bundleDescription;
262      EXIT WHEN bundleCur%NOTFOUND;
263  
264      -- Check against currently installed bundle ID.  We will include this
265      -- bundle if there are no currently installed bundles, or if the
266      -- currently installed bundle ID <= this bundle ID.
267      -- If the patch mode is rollback, then we will include all bundles.
268      DBMS_OUTPUT.PUT_LINE('Processing components and files for bundle ' ||
269                           bundleID || ': ' || bundleDescription);
270  
271      IF bundleID >= startingBundle THEN
272        rollbackOnly := 'N';
273      ELSE
274        rollbackOnly := 'Y';
275      END If;
276  
277      -- For each component within that bundle:
278      OPEN componentCur(bundle);
279      LOOP
280        FETCH componentCur INTO component, componentID;
281        EXIT WHEN componentCur%NOTFOUND;
282  
283        -- For each file within that component:
284        OPEN fileCur(component);
285        LOOP
286          FETCH fileCur INTO filename, priority;
287          EXIT WHEN fileCur%NOTFOUND;
288  
289          -- Insert into bundle_component_files to trap duplicates
290          -- 10413872: Add priority
291          BEGIN
292            INSERT INTO bundle_component_files
293                (cid, fname, seq, priority, rollback_only)
294              VALUES
295                (componentID, filename, filenameSeq, priority, rollbackOnly);
296            filenameSeq := filenameSeq + 1;
297          EXCEPTION
298            WHEN DUP_VAL_ON_INDEX THEN
299              -- File is already present for this component, just update
300              -- rollback_only if needed
301              IF rollbackOnly = 'N' THEN
302                UPDATE bundle_component_files
303                  SET rollback_only = 'N'
304                  WHERE cid = componentID
305                  AND fname = filename;
306              END IF;
307          END;
308  
309        END LOOP;
310        CLOSE fileCur;
311  
312      END LOOP;
313      CLOSE componentCur;
314  
315    END LOOP;
316    CLOSE bundleCur;
317  
318    -- Now bundle_component_files has the (unique) list of files for each
319    -- component.  The next step is to generate the output scripts.
320    openScriptFiles(:applyScriptFile, :rollbackScriptFile);
321  
322    insertScriptFile('A', 'REM This script is ' || :applyScriptFile);
323    insertScriptFile('R', 'REM This script is ' || :rollbackScriptFile);
324    insertScriptFile('B', 'REM It was generated by catbundle.sql on ' ||
325                          TO_CHAR(SYSDATE, 'YYYYMonDD_hh24_mi_ss',
326                                  'NLS_DATE_LANGUAGE=''AMERICAN'''));
327  
328    insertScriptFile('B', 'SET echo on');
329  
330    -- Generate spool commands
331    insertScriptFile('B', 'COLUMN spool_file NEW_VALUE spool_file NOPRINT');
332  
333    spoolCommand :=
334      'SELECT ''' || :catbundleLogDir || ''' || ''catbundle_' || bundleSeries ||
335      '_'' || name || ''_APPLY_'' || ' ||
336      'TO_CHAR(SYSDATE, ''YYYYMonDD_hh24_mi_ss'', ' ||
337                        '''NLS_DATE_LANGUAGE=''''AMERICAN'''''') || ' ||
338      '''.log''' ||
339      ' AS spool_file FROM v$database;';
340    insertScriptFile('A', spoolCommand);
341  
342  
343    spoolCommand :=
344      'SELECT ''' || :catbundleLogDir || ''' || ''catbundle_' || bundleSeries ||
345      '_'' || name || ''_ROLLBACK_'' || ' ||
346      'TO_CHAR(SYSDATE, ''YYYYMonDD_hh24_mi_ss'', ' ||
347                        '''NLS_DATE_LANGUAGE=''''AMERICAN'''''') || ' ||
348      '''.log''' ||
349      ' AS spool_file FROM v$database;';
350    insertScriptFile('R', spoolCommand);
351    insertScriptFile('B', 'SPOOL &' || 'spool_file');
352  
353    -- 8498426: Set namespace
354    insertScriptFile('B', 'exec sys.dbms_registry.set_session_namespace(''SERVER'')');
355  
356    -- 19727057: If javavm/install/jvmpsu.sql exists, execute it first.
357    IF file_exists(:javavmInstallDir, 'jvmpsu.sql') THEN
358      insertScriptFile('B', 'PROMPT Calling jvmpsu.sql to initialize Java...');
359      insertScriptFile('B', '@?/javavm/install/jvmpsu.sql');
360    END IF;
361  
362    FOR componentInfoRec IN componentInfoCur(bundledata) LOOP
363      compHeaderWritten := TRUE;
364  
365      IF componentOK(componentInfoRec.compID) THEN
366        OPEN bundleComponentFilesCur(componentInfoRec.compID);
367        LOOP
368          FETCH bundleComponentFilesCur INTO filename, rollbackOnly;
369          EXIT WHEN bundleComponentFilesCur%NOTFOUND;
370  
371          -- Ensure that we switch schemas only if the component has files to
372          -- process.
373          IF compHeaderWritten THEN
374            insertScriptFile('R',
375              'PROMPT Processing ' || componentInfoRec.compName || '...');
376            insertScriptFile('R',
377              'ALTER SESSION SET current_schema = ' ||
378               componentInfoRec.compSchema || ';');
379            -- If any of the files are marked rollback_only = 'N' then
380            -- output to the apply file
381            DECLARE
382              rollback_count NUMBER;
383            BEGIN
384              SELECT COUNT(*)
385                INTO rollback_count
386                FROM bundle_component_files
387                WHERE cid = componentInfoRec.compID
388                AND rollback_only = 'N';
389              IF rollback_count > 0 THEN
390                insertScriptFile('A',
391                  'PROMPT Processing ' || componentInfoRec.compName || '...');
392                insertScriptFile('A',
393                  'ALTER SESSION SET current_schema = ' ||
394                   componentInfoRec.compSchema || ';');
395              END IF;
396            END;
397            compHeaderWritten := FALSE;
398          END IF;
399  
400          insertScriptFile('R', '@' || filename);
401          IF rollbackOnly = 'N' THEN
402            insertScriptFile('A', '@' || filename);
403          END IF;
404        END LOOP;
405        CLOSE bundleComponentFilesCur;
406      ELSE
407        insertScriptFile('B',
408          'PROMPT Skipping ' || componentInfoRec.compName ||
409          ' because it is not installed or versions mismatch...');
410      END IF;
411    END LOOP;
412  
413    -- Switch user back to SYS
414    insertScriptFile('B', 'ALTER SESSION SET current_schema = SYS;');
415  
416    -- Update the registry if we've actually done something.
417    IF (bundleID IS NOT NULL) THEN
418      insertScriptFile('B', 'PROMPT Updating registry...');
419      insertScriptFile('B', 'INSERT INTO registry$history ');
420      insertScriptFile('B', '  (action_time, action,');
421      insertScriptFile('B', '   namespace, version, id, ');
422      insertScriptFile('B', '   bundle_series, comments)');
423      insertScriptFile('B', 'VALUES');
424      insertScriptFile('A', '  (SYSTIMESTAMP, ''APPLY'', ');
425      insertScriptFile('R', '  (SYSTIMESTAMP, ''ROLLBACK'', ');
426      insertScriptFile('B', '   SYS_CONTEXT(''REGISTRY$CTX'',''NAMESPACE''), ');
427      insertScriptFile('B', '   ''' || currentDBVersion || ''', ');
428      insertScriptFile('B', '   ' || bundleID || ', ');
429      insertScriptFile('B', '   ''' || bundleSeries || ''',');
430      insertScriptFile('B', '   ''' || bundleDescription || ''');');
431    END IF;
432  
433    insertScriptFile('B', 'COMMIT;');
434    insertScriptFile('B', 'SPOOL off');
435    insertScriptFile('B', 'SET echo off');
436    insertScriptFile('B', 'PROMPT Check the following log file for errors:');
437    insertScriptFile('B', 'PROMPT &' || 'spool_file');
438  
439    -- 13866822: Add call to apply in the rollback script.  The idea is that
440    -- a rollback will roll back all the way to bundle 0, but the binary
441    -- level may not be bundle 0.  So we need to regenerate and run the apply
442    -- script.
443    insertScriptFile('R', '@@?/rdbms/admin/catbundle.sql &bundle_series apply');
444    closeScriptFiles;
445  
446    DBMS_OUTPUT.PUT_LINE('Apply SQL file: ' || :applyScriptFile);
447    DBMS_OUTPUT.PUT_LINE('Rollback SQL file: ' || :rollbackScriptFile);
448  
449  EXCEPTION
450    WHEN fileopenFailed THEN
451      DBMS_OUTPUT.PUT_LINE(
452        'Error reading ' || xmlFilename || ' - patch NOT installed');
453      DBMS_OUTPUT.PUT_LINE('Ensure that the file exists in ' || :rdbmsAdminDir);
454      DBMS_OUTPUT.PUT_LINE(SQLERRM);
455      :scriptFile := :rdbmsAdminDir || 'nothing.sql';  -- We need to run something
456    WHEN invalidMode THEN
457      DBMS_OUTPUT.PUT_LINE(
458        'Invalid mode ' || patchMode || ' - patch NOT installed');
459      DBMS_OUTPUT.PUT_LINE('Mode must be either apply or rollback');
460      :scriptFile := :rdbmsAdminDir || 'nothing.sql';  -- We need to run something
461    WHEN OTHERS THEN
462      DBMS_OUTPUT.PUT_LINE('Exception - patch NOT installed');
463      DBMS_OUTPUT.PUT_LINE(SQLERRM);
464      :scriptFile := :rdbmsAdminDir || 'nothing.sql';  -- We need to run something
465  END;
466  /
Exception - patch NOT installed                                                                                                                                                                         
ORA-31024: Parser initialization failed with LPX-201 error
while parsing a stream to XOB                                                                                                                

PL/SQL procedure successfully completed.

SQL> 
SQL> REM Enable Symlink/Mountpoint checks (required for windows platform)
SQL> DECLARE
  2    stmt                VARCHAR2(1000);
  3  BEGIN
  4    -- alter session: disable use of symbolic links
  5    -- (restore the variable to its prior value)
  6    stmt := 'ALTER SESSION SET "_kolfuseslf" = ' || :kolfuseslf;
  7    EXECUTE IMMEDIATE stmt;
  8  END;
  9  /

PL/SQL procedure successfully completed.

SQL> 
SQL> PROMPT Dropping temporary objects...
Dropping temporary objects...
SQL> TRUNCATE TABLE bundle_component_files;

Table truncated.

SQL> DROP TABLE bundle_component_files;

Table dropped.

SQL> DROP DIRECTORY admin_dir;

Directory dropped.

SQL> DROP FUNCTION dir_exists_and_is_writable;

Function dropped.

SQL> DROP FUNCTION file_exists;

Function dropped.

SQL> 
SQL> 
SQL> SET ECHO off
Apply script: /u01/app/oracle/product/11.2.0.4/dbhome_1/rdbms/admin/catbundle_PSU_ORCL_APPLY.sql                                                                                                        
Rollback script: /u01/app/oracle/product/11.2.0.4/dbhome_1/rdbms/admin/catbundle_PSU_ORCL_ROLLBACK.sql                                                                                                  

PL/SQL procedure successfully completed.

Executing script file...
